/** *****************************************************************************
 * @file    	data_logger.cpp
 * @brief   	data logging to uSD
 * @author  	Dr. Klaus Schaefer,  some adaptions by Maximilian Betz
 * @copyright 	Copyright 2021 Dr. Klaus Schaefer. All rights reserved.
 * @license 	This project is released under the GNU Public License GPL-3.0

    <Larus Flight Sensor Firmware>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

 **************************************************************************/

 #include "system_configuration.h"
#include "main.h"
#include "FreeRTOS_wrapper.h"
#include "fatfs.h"
#include "common.h"
#include "ascii_support.h"
#include "git-commit-version.h"  /* generated by a git post commit hook in /githooks.  */
#include "Linear_Least_Square_Fit.h"
#include "data_structures.h"
#include "read_configuration_file.h"
#include "communicator.h"
#include "emergency.h"

extern Semaphore setup_file_handling_completed;
extern uint32_t UNIQUE_ID[4];

COMMON Queue< linear_least_square_result<float>[3] > magnetic_calibration_queue(4,"M_CALIB");
COMMON char *crashfile;
COMMON unsigned crashline;

#if RUN_DATA_LOGGER

FATFS fatfs;
extern SD_HandleTypeDef hsd;
extern DMA_HandleTypeDef hdma_sdio_rx;
extern DMA_HandleTypeDef hdma_sdio_tx;
extern int64_t FAT_time; //!< DOS FAT time for file usage

#define MEM_BUFSIZE 2048 // bytes
#define RESERVE 512
static uint8_t __ALIGNED(MEM_BUFSIZE) mem_buffer[MEM_BUFSIZE + RESERVE];

char * format_date_time( char * target)
{
  target = format_2_digits( target, output_data.c.year);
  target = format_2_digits( target, output_data.c.month);
  target = format_2_digits( target, output_data.c.day);
  *target ++ = '_';
  target = format_2_digits( target, output_data.c.hour);
  target = format_2_digits( target, output_data.c.minute);
  target = format_2_digits( target, output_data.c.second);
  *target=0;
  return target;
}

void newline( char * &next)
{
  *next++ = '\r';
  *next++ = '\n';
}

void write_crash_dump( void)
{
  FRESULT fresult;
  FIL fp;
  char buffer[50];
  char *next = buffer;
  int32_t writtenBytes = 0;

#if configUSE_TRACE_FACILITY // ************************************************
#include "trcConfig.h"
  vTraceStop(); // don't trace ourselves ...
#endif

  next = format_date_time( buffer);
  next = append_string (next, ".CRASHDUMP");

  fresult = f_open (&fp, buffer, FA_CREATE_ALWAYS | FA_WRITE);
  if (fresult != FR_OK)
    return;

  next=append_string( buffer, (char*)"Firmware: ");
  next=append_string( next, GIT_TAG_INFO);
  newline( next);

  f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);

  next=append_string( buffer, (char*)"Hardware: ");
  next = utox( UNIQUE_ID[0], next, 8);
  newline( next);

  f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);

  next=append_string( buffer, crashfile);
  next=append_string( next, (char*)" Line: ");
  next = my_itoa( next, crashline);
  newline( next);

  f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);

  next=append_string( buffer, (char*)"Task:     ");
  next=append_string( next, pcTaskGetName( (TaskHandle_t)(register_dump.active_TCB)));
  newline( next);

  f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);

  next=append_string( buffer, (char*)"PC:       ");
  next = utox( register_dump.stacked_pc, next);
  newline( next);
  next=append_string( next, (char*)"LR:       ");
  next = utox( register_dump.stacked_lr, next);
  newline( next);

  f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);

  next=append_string( buffer, (char*)"BusFA:    ");
  next = utox( register_dump.Bus_Fault_Address, next);
  newline( next);

  f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);

  next=append_string( buffer, (char*)"MemA:     ");
  next = utox( register_dump.Bad_Memory_Address, next);
  newline( next);

  next=append_string( next, (char*)"MemFS:    ");
  next = utox( register_dump.Memory_Fault_status, next);
  newline( next);

  f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);

  next=append_string( buffer, (char*)"FPU_S:    ");
  next = utox( register_dump.FPU_StatusControlRegister, next);
  newline( next);

  next=append_string( next, (char*)"UsgFS:    ");
  next = utox( register_dump.Usage_Fault_Status_Register, next);
  newline( next);

  f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);

  next=append_string( buffer, (char*)"HardFS:   ");
  next = utox( register_dump.Hard_Fault_Status, next);
  newline( next);

  f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);

  f_close(&fp);

#if configUSE_TRACE_FACILITY // ************************************************

extern RecorderDataType myTraceBuffer;
  next = format_date_time( buffer);
  next = append_string (next, ".bin");
  fresult = f_open (&fp, buffer, FA_CREATE_ALWAYS | FA_WRITE);
  if (fresult != FR_OK)
    return;


  for( uint8_t *ptr=(uint8_t *)&myTraceBuffer; ptr < (uint8_t *)&myTraceBuffer + sizeof(RecorderDataType); ptr += 2048)
    {
      size_t size = (uint8_t *)&myTraceBuffer + sizeof(RecorderDataType) - ptr;
      if( size > MEM_BUFSIZE)
	size = MEM_BUFSIZE;
      memcpy( mem_buffer, ptr, size);
      fresult = f_write (&fp, (const void *)mem_buffer, size, (UINT*) &writtenBytes);
      ASSERT( writtenBytes == MEM_BUFSIZE);
    }
  f_close(&fp);

#endif // ************************************************************************

  delay(1000); // wait until data has been saved and file is closed

  extern RestrictedTask data_logger;
  data_logger.set_priority(LOGGER_PRIORITY + 5);
  while( true)
    /* wake watchdog */;
}

void write_EEPROM_dump( const char * filename)
{
  FRESULT fresult;
  FIL fp;
  char buffer[50];
  char *next = buffer;
  int32_t writtenBytes = 0;

  next = append_string (next, filename);
  next = append_string (next, ".EEPROM");
  *next=0;

  fresult = f_open (&fp, buffer, FA_CREATE_ALWAYS | FA_WRITE);
  if (fresult != FR_OK)
    return;

  f_write (&fp, GIT_TAG_INFO, strlen(GIT_TAG_INFO), (UINT*) &writtenBytes);
  f_write (&fp, "\r\n", 2, (UINT*) &writtenBytes);
  utox( UNIQUE_ID[0], buffer, 8);
  buffer[8]='\r';
  buffer[9]='\n';
  f_write (&fp, buffer, 10, (UINT*) &writtenBytes);

  for( unsigned index = 1; index < PERSISTENT_DATA_ENTRIES; ++index)
    {
      float value;
      bool result = read_EEPROM_value( PERSISTENT_DATA[index].id, value);
      if( result == HAL_OK)
	{
	      next = buffer;
	      next = format_2_digits(next, PERSISTENT_DATA[index].id);
	      *next++=' ';
	      next = append_string( next, PERSISTENT_DATA[index].mnemonic);
	      next = append_string (next," = ");
	      next = my_ftoa (next, value);
	      *next++='\r';
	      *next++='\n';
	      *next=0;
	      fresult = f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);
	      if( (fresult != FR_OK) || (writtenBytes != (next-buffer)))
		{
		f_close(&fp);
	        return;
		}
	}
      }

  f_close(&fp);
}

void write_magnetic_calibration_file (const coordinates_t &c)
{
  FRESULT fresult;
  FIL fp;
  char buffer[50];
  char *next = buffer;
  linear_least_square_result<float> data[3];
  int32_t writtenBytes = 0;

  if (false == magnetic_calibration_queue.receive (data, 0))
    return;

  next = format_2_digits(next, c.year);
  next = format_2_digits(next, c.month);
  next = format_2_digits(next, c.day);
  *next++ = '_';
  next = format_2_digits(next, c.hour);
  next = format_2_digits(next, c.minute);
  next = format_2_digits(next, c.second);

  *next++ = (char)(data[0].id);

  append_string(next, ".mcl");

  fresult = f_open (&fp, buffer, FA_CREATE_ALWAYS | FA_WRITE);
  if (fresult != FR_OK)
    return; // silently give up

  for( unsigned i=0; i<3; ++i)
    {
      char *next = buffer;
      next = my_ftoa (next, data[i].y_offset);
      *next++='\t';
      next = my_ftoa (next, data[i].slope);
      *next++='\t';
      next = my_ftoa (next, data[i].variance_offset);
      *next++='\t';
      next = my_ftoa (next, data[i].variance_slope);
      *next++='\t';
      fresult = f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);
      if( (fresult != FR_OK) || (writtenBytes != (next-buffer)))
        return;
    }
  f_write (&fp, "\r\n", 2, (UINT*) &writtenBytes);
  f_close(&fp);
}

void
data_logger_runnable (void*)
{
  HAL_SD_DeInit (&hsd);
  delay (2000); //TODO: Quick consecutive resets cause SD Card to hang. This improved but does not fix the situation. Might require switching sd card power

  char out_filename[30];
  FRESULT fresult;
  FIL outfile;

  // wait until sd card is detected
  for( int i=10; i>0 && (! BSP_PlatformIsDetected()); --i)
      delay (1000);
  delay (100); // wait until card is plugged correctly

  fresult = f_mount (&fatfs, "", 0);

  if (fresult != FR_OK)
    {
      setup_file_handling_completed.signal();
      while(true)
	suspend (); // give up, logger can not work
    }

  read_configuration_file(); // read configuration file if it is present on the SD card
  setup_file_handling_completed.signal();
#if 0 // fixme patch
  // wait until a GNSS timestamp is available.
  while (output_data.c.sat_fix_type == 0)
    {
      if( crashfile)
	write_crash_dump();

      delay (100); /* klaus: this bad guy has implemented a spinlock (max) */
    }
#endif
  // generate filename based on timestamp
  int idx = 0;
  itoa (2000 + output_data.c.year, out_filename, 10);
  while (out_filename[idx] != 0)
    idx++;
  if (output_data.c.month < 10)
    {
      out_filename[idx] = '0';
      idx++;
    }
  itoa (output_data.c.month, &out_filename[idx], 10);
  while (out_filename[idx] != 0)
    idx++;

  if (output_data.c.day < 10)
    {
      out_filename[idx] = '0';
      idx++;
    }
  itoa (output_data.c.day, &out_filename[idx], 10);
  while (out_filename[idx] != 0)
    idx++;

  if (output_data.c.hour < 10)
    {
      out_filename[idx] = '0';
      idx++;
    }
  itoa (output_data.c.hour, &out_filename[idx], 10);
  while (out_filename[idx] != 0)
    idx++;

  if (output_data.c.minute < 10)
    {
      out_filename[idx] = '0';
      idx++;
    }
  itoa (output_data.c.minute, &out_filename[idx], 10);
  while (out_filename[idx] != 0)
    idx++;

  if (output_data.c.second < 10)
    {
      out_filename[idx] = '0';
      idx++;
    }
  itoa (output_data.c.second, &out_filename[idx], 10);
  while (out_filename[idx] != 0)
    idx++;

  out_filename[idx] = '.';
  out_filename[idx + 1] = 'f';

  itoa ((sizeof(coordinates_t) + sizeof(measurement_data_t)) / sizeof(float),
	out_filename + idx + 2, 10);

  GPIO_PinState led_state = GPIO_PIN_RESET;

  uint32_t writtenBytes = 0;
  uint8_t *buf_ptr = mem_buffer;

  write_EEPROM_dump( out_filename);

  fresult = f_open (&outfile, out_filename, FA_CREATE_ALWAYS | FA_WRITE);
  if (fresult != FR_OK)
    suspend (); // give up, logger unable to work

  int32_t sync_counter=0;

  while( true) // logger loop synchronized by communicator
    {
      notify_take (true); // wait for synchronization by from communicator

      if( crashfile)
	write_crash_dump();

      memcpy (buf_ptr, (uint8_t*) &output_data.m, sizeof(measurement_data_t)+sizeof(coordinates_t));
      buf_ptr += sizeof(measurement_data_t)+sizeof(coordinates_t);

      if (buf_ptr < mem_buffer + MEM_BUFSIZE)
	continue; // buffer only filled partially

      fresult = f_write (&outfile, mem_buffer, MEM_BUFSIZE, (UINT*) &writtenBytes);
      if( ! ((fresult == FR_OK) && (writtenBytes == MEM_BUFSIZE)))
	while(true)
	  suspend (); // give up, logger can not work

      uint32_t rest = buf_ptr - (mem_buffer + MEM_BUFSIZE);
      memcpy (mem_buffer, mem_buffer + MEM_BUFSIZE, rest);
      buf_ptr = mem_buffer + rest;

      if( ++sync_counter >= 16)
	{
	  f_sync (&outfile);
	  sync_counter = 0;
#if uSD_LED_STATUS
	  HAL_GPIO_WritePin (LED_STATUS1_GPIO_Port, LED_STATUS2_Pin, led_state);
	  led_state = led_state == GPIO_PIN_RESET ? GPIO_PIN_SET : GPIO_PIN_RESET;
#endif
#if LOG_MAGNETIC_CALIBRATION
	  write_magnetic_calibration_file ( output_data.c);
#endif
	}
    }
}

#define STACKSIZE (1024*2)
static uint32_t __ALIGNED(STACKSIZE*4) stack_buffer[STACKSIZE];

static TaskParameters_t p =
  { data_logger_runnable, "LOGGER",
  STACKSIZE, 0,
  LOGGER_PRIORITY + portPRIVILEGE_BIT, stack_buffer,
    {
      { COMMON_BLOCK, COMMON_SIZE, portMPU_REGION_READ_WRITE },
      { (void *)0x80f8000, 0x8000, portMPU_REGION_READ_WRITE },
      { 0, 0, 0 } } };

COMMON RestrictedTask data_logger (p);

extern "C" void sync_logger(void)
  {
    data_logger.notify_give ();
  }

extern "C" void emergency_write_crashdump( char * file, int line)
  {
    crashfile=file;
    crashline=line;
  }

#endif
