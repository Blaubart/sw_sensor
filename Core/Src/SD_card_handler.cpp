/** *****************************************************************************
 * @file    data_logger.cpp
 * @author  Klaus Schaefer,  some adaptions by Maximilian Betz
 * @brief   data logging to uSD
 ******************************************************************************/

#include "system_configuration.h"
#include "main.h"
#include "FreeRTOS_wrapper.h"
#include "fatfs.h"
#include "common.h"
#include "ascii_support.h"
#include "git-commit-version.h"  /* generated by a git post commit hook in /githooks.  */
#include "Linear_Least_Square_Fit.h"
#include "data_structures.h"
#include "read_configuration_file.h"
#include "communicator.h"
#include "system_state.h"

extern Semaphore SD_card_to_communicator_synchronizer;
extern bool replaying_data;
extern uint32_t UNIQUE_ID[4];

COMMON Queue< linear_least_square_result<float>[3] > magnetic_calibration_queue(4);
COMMON char *crashfile;
COMMON unsigned crashline;
COMMON uint64_t crashdata;

#if RUN_DATA_LOGGER

FATFS fatfs;
extern SD_HandleTypeDef hsd;
extern DMA_HandleTypeDef hdma_sdio_rx;
extern DMA_HandleTypeDef hdma_sdio_tx;
extern int64_t FAT_time; //!< DOS FAT time for file usage

#define BUFSIZE 2048 // bytes
#define RESERVE 512
static uint8_t __ALIGNED(BUFSIZE) buffer[BUFSIZE + RESERVE];

extern uint32_t Bus_Fault_Address;
extern uint8_t  Bus_Fault_Status;
extern uint32_t Bad_Memory_Address;
extern uint32_t Memory_Fault_status;
extern uint32_t Bad_Instruction_Address;
extern uint32_t FPU_StatusControlRegister;
extern uint16_t Usage_Fault_Status_Register;
extern uint32_t Hard_Fault_Status;

class flight_data_reader
  {
  public:
    flight_data_reader( const char * filename)
       : file_is_open(false)
    {
      FRESULT fresult;
      fresult = f_open(&infile, filename, FA_READ);
      if( fresult != FR_OK)
        return;

      file_is_open=true;
    }

//! @return true if next record has been read
  bool read_record( observations_type *target)
  {
    if( ! file_is_open)
      return false;

    UINT bytesread;
    FRESULT fresult;
    fresult = f_read(&infile, target, sizeof( observations_type), &bytesread);
    if( (fresult != FR_OK) || (bytesread != sizeof( observations_type)))
      {
	f_close( &infile);
	return false;
      }
    return true;
  }
  bool is_open( void)
  {
    return file_is_open;
  }
  void close( void)
  {
    if( file_is_open)
      {
	FRESULT fresult;
	fresult = f_close( &infile);
      }
  }
private:
  FIL infile;
  bool file_is_open;
};

void write_crash_dump( void)
{
  FRESULT fresult;
  FIL fp;
  char buffer[50];
  char *next = buffer;
  int32_t writtenBytes = 0;

  next = utox( buffer, (unsigned)FAT_time);
  next = append_string (next, ".CRASHDUMP");
  *next=0;

  fresult = f_open (&fp, buffer, FA_CREATE_ALWAYS | FA_WRITE);
  if (fresult != FR_OK)
    return;

  f_write (&fp, GIT_TAG_INFO, strlen(GIT_TAG_INFO), (UINT*) &writtenBytes);
  f_write (&fp, "\r\n", 2, (UINT*) &writtenBytes);
  utox( buffer, UNIQUE_ID[0], 8);
  buffer[8]='\r';
  buffer[9]='\n';
  f_write (&fp, buffer, 10, (UINT*) &writtenBytes);

  f_write (&fp, crashfile, strlen(crashfile), (UINT*) &writtenBytes);

  next = buffer;
  *next++=' ';
  next = my_itoa( next, crashline);
  newline(next);

  next = lutox( next, crashdata);
  newline(next);
  f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);

  next = utox( buffer, Bus_Fault_Address);
  newline(next);

  next = utox( next, Bad_Memory_Address);
  newline(next);

  next = utox( next, Memory_Fault_status);
  newline(next);

  next = utox( next, Bad_Instruction_Address);
  newline(next);
  f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);

  next = utox( buffer, FPU_StatusControlRegister);
  newline(next);

  next = utox( next, Usage_Fault_Status_Register);
  newline(next);

  next = utox( next, Hard_Fault_Status);
  newline(next);

  f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);

  f_close(&fp);

  delay(1000); // wait until data has been saved and file is closed

  extern RestrictedTask data_logger;
  data_logger.set_priority(LOGGER_PRIORITY + 5);
  while( true)
    /* wake watchdog */;
}

void write_EEPROM_dump( const char * filename)
{
  FRESULT fresult;
  FIL fp;
  char buffer[50];
  char *next = buffer;
  int32_t writtenBytes = 0;

  next = append_string (next, filename);
  next = append_string (next, ".EEPROM");
  *next=0;

  fresult = f_open (&fp, buffer, FA_CREATE_ALWAYS | FA_WRITE);
  if (fresult != FR_OK)
    return;

  f_write (&fp, GIT_TAG_INFO, strlen(GIT_TAG_INFO), (UINT*) &writtenBytes);
  f_write (&fp, "\r\n", 2, (UINT*) &writtenBytes);
  utox( buffer, UNIQUE_ID[0], 8);
  buffer[8]='\r';
  buffer[9]='\n';
  f_write (&fp, buffer, 10, (UINT*) &writtenBytes);

  for( unsigned index = 1; index < PERSISTENT_DATA_ENTRIES; ++index)
    {
      float value;
      bool result = read_EEPROM_value( PERSISTENT_DATA[index].id, value);
      if( result == HAL_OK)
	{
	      next = buffer;
	      next = format_2_digits(next, PERSISTENT_DATA[index].id);
	      *next++=' ';
	      next = append_string( next, PERSISTENT_DATA[index].mnemonic);
	      next = append_string (next," = ");
	      next = my_ftoa (next, value);
	      *next++='\r';
	      *next++='\n';
	      *next=0;
	      fresult = f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);
	      if( (fresult != FR_OK) || (writtenBytes != (next-buffer)))
		{
		f_close(&fp);
	        return;
		}
	}
      }

  f_close(&fp);
}

void write_magnetic_calibration_file (const coordinates_t &c)
{
  FRESULT fresult;
  FIL fp;
  char buffer[50];
  char *next = buffer;
  linear_least_square_result<float> data[3];
  int32_t writtenBytes = 0;

  if (false == magnetic_calibration_queue.receive (data, 0))
    return;

  next = format_2_digits(next, c.year);
  next = format_2_digits(next, c.month);
  next = format_2_digits(next, c.day);
  *next++ = '_';
  next = format_2_digits(next, c.hour);
  next = format_2_digits(next, c.minute);
  next = format_2_digits(next, c.second);

  *next++ = (char)(data[0].id);

  append_string(next, ".mcl");

  fresult = f_open (&fp, buffer, FA_CREATE_ALWAYS | FA_WRITE);
  if (fresult != FR_OK)
    return; // silently give up

  for( unsigned i=0; i<3; ++i)
    {
      char *next = buffer;
      next = my_ftoa (next, data[i].y_offset);
      *next++='\t';
      next = my_ftoa (next, data[i].slope);
      *next++='\t';
      next = my_ftoa (next, data[i].variance_offset);
      *next++='\t';
      next = my_ftoa (next, data[i].variance_slope);
      *next++='\t';
      fresult = f_write (&fp, buffer, next-buffer, (UINT*) &writtenBytes);
      if( (fresult != FR_OK) || (writtenBytes != (next-buffer)))
        return;
    }
  f_write (&fp, "\r\n", 2, (UINT*) &writtenBytes);
  f_close(&fp);
}

void
data_logger_runnable (void*)
{
  HAL_SD_DeInit (&hsd);
  delay (2000); //TODO: Quick consecutive resets cause SD Card to hang. This improved but does not fix the situation. Might require switching sd card power

  char out_filename[30];
  FRESULT fresult;
  FIL outfile;

  // wait until sd card is detected
  for( int i=10; i>0 && (! BSP_PlatformIsDetected()); --i)
      delay (1000);
  delay (100); // wait until card is plugged correctly

  fresult = f_mount (&fatfs, "", 0);

  if (fresult != FR_OK)
    {
      SD_card_to_communicator_synchronizer.signal();
      while(true)
	suspend (); // give up, logger can not work
    }

  ASSERT( sizeof( observations_type) == 50 * sizeof(float));
  flight_data_reader input_reader( "flight_data.f50");
  if( input_reader.is_open())
    {
      read_configuration_file( (char *)"flight_data.EEPROM", true); // read configuration dump file if it is present on the SD card

      replaying_data = true;
      // fake system state = "basic sensors operative"
      system_state = GNSS_AVAILABLE | MTI_SENSOR_AVAILABE | MS5611_STATIC_AVAILABLE | PITOT_SENSOR_AVAILABLE;

      while( input_reader.read_record( (observations_type *)&output_data))
	{
		SD_card_to_communicator_synchronizer.signal();
		delay(10);
	}

      input_reader.close();
      while( true)
	; // wait for watchdog
    }

  read_configuration_file(); // read configuration file if it is present on the SD card
  SD_card_to_communicator_synchronizer.signal();

  // wait until a GNSS timestamp is available.
  while (output_data.c.sat_fix_type == 0)
    {
      if( crashfile)
	write_crash_dump();

      delay (100); /* klaus: this bad guy has implemented a spinlock (max) */
    }

  // generate filename based on timestamp
  int idx = 0;
  itoa (2000 + output_data.c.year, out_filename, 10);
  while (out_filename[idx] != 0)
    idx++;
  if (output_data.c.month < 10)
    {
      out_filename[idx] = '0';
      idx++;
    }
  itoa (output_data.c.month, &out_filename[idx], 10);
  while (out_filename[idx] != 0)
    idx++;

  if (output_data.c.day < 10)
    {
      out_filename[idx] = '0';
      idx++;
    }
  itoa (output_data.c.day, &out_filename[idx], 10);
  while (out_filename[idx] != 0)
    idx++;

  if (output_data.c.hour < 10)
    {
      out_filename[idx] = '0';
      idx++;
    }
  itoa (output_data.c.hour, &out_filename[idx], 10);
  while (out_filename[idx] != 0)
    idx++;

  if (output_data.c.minute < 10)
    {
      out_filename[idx] = '0';
      idx++;
    }
  itoa (output_data.c.minute, &out_filename[idx], 10);
  while (out_filename[idx] != 0)
    idx++;

  if (output_data.c.second < 10)
    {
      out_filename[idx] = '0';
      idx++;
    }
  itoa (output_data.c.second, &out_filename[idx], 10);
  while (out_filename[idx] != 0)
    idx++;

  out_filename[idx] = '.';
  out_filename[idx + 1] = 'f';

  itoa ((sizeof(coordinates_t) + sizeof(measurement_data_t)) / sizeof(float),
	out_filename + idx + 2, 10);

  GPIO_PinState led_state = GPIO_PIN_RESET;

  uint32_t writtenBytes = 0;
  uint8_t *buf_ptr = buffer;

  write_EEPROM_dump( out_filename);

  fresult = f_open (&outfile, out_filename, FA_CREATE_ALWAYS | FA_WRITE);
  if (fresult != FR_OK)
    suspend (); // give up, logger unable to work

  int32_t sync_counter=0;

  while( true) // logger loop synchronized by communicator
    {
      notify_take (true); // wait for synchronization by from communicator

      if( crashfile)
	write_crash_dump();

      memcpy (buf_ptr, (uint8_t*) &output_data.m, sizeof(measurement_data_t)+sizeof(coordinates_t));
      buf_ptr += sizeof(measurement_data_t)+sizeof(coordinates_t);

      if (buf_ptr < buffer + BUFSIZE)
	continue; // buffer only filled partially

      fresult = f_write (&outfile, buffer, BUFSIZE, (UINT*) &writtenBytes);
      if( ! ((fresult == FR_OK) && (writtenBytes == BUFSIZE)))
	while(true)
	  suspend (); // give up, logger can not work

      uint32_t rest = buf_ptr - (buffer + BUFSIZE);
      memcpy (buffer, buffer + BUFSIZE, rest);
      buf_ptr = buffer + rest;

      if( ++sync_counter >= 16)
	{
	  f_sync (&outfile);
	  sync_counter = 0;
#if uSD_LED_STATUS
	  HAL_GPIO_WritePin (LED_STATUS1_GPIO_Port, LED_STATUS2_Pin, led_state);
	  led_state = led_state == GPIO_PIN_RESET ? GPIO_PIN_SET : GPIO_PIN_RESET;
#endif
#if LOG_MAGNETIC_CALIBRATION
	  write_magnetic_calibration_file ( output_data.c);
#endif
	}
    }
}

#define STACKSIZE (1024*2)
static uint32_t __ALIGNED(STACKSIZE*4) stack_buffer[STACKSIZE];

static TaskParameters_t p =
  { data_logger_runnable, "LOGGER",
  STACKSIZE, 0,
  LOGGER_PRIORITY + portPRIVILEGE_BIT, stack_buffer,
    {
      { COMMON_BLOCK, COMMON_SIZE, portMPU_REGION_READ_WRITE },
      { (void *)0x80f8000, 0x8000, portMPU_REGION_READ_WRITE },
      { 0, 0, 0 } } };

COMMON RestrictedTask data_logger (p);

extern "C" void sync_logger(void)
  {
    data_logger.notify_give ();
  }

extern "C" void emergency_write_crashdump( char * file, int line, uint64_t data)
  {
    crashfile=file;
    crashline=line;
    crashdata=data;
  }

#endif
